\documentclass[a4paper, oneside, final]{memoir}
% Fixes "No room for a new \xxx" error by extending the default 256 fixed size
% LaTeX arrays
\usepackage{etex}
\reserveinserts{28}


\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}

% bedre orddeling Gør at der som minimum skal blive to tegn på linien ved
% orddeling og minimum flyttes to tegn ned på næste linie. Desværre er værdien
% anvendt af babel »12«, hvilket kan give orddelingen »h-vor«.
\renewcommand{\britishhyphenmins}{22} 

% Fix of fancyref to work with memoir. Makes references look
% nice. Redefines memoir \fref and \Fref to \refer and \Refer.
% \usepackage{refer}             %
% As we dont really have any use for \fref and \Fref we just undefine what
% memoir defined them as, so fancyref can define what it wants.
\let\fref\undefined
\let\Fref\undefined
\usepackage{fancyref} % Better reference. 

\usepackage{pdflscape} % Gør landscape-environmentet tilgængeligt
\usepackage[draft]{fixme}     % Indsæt "fixme" noter i drafts.
\usepackage{hyperref}  % Indsæter links (interne og eksterne) i PDF

\usepackage[rounded]{syntax} % Part of the mdwtools package

\usepackage{mdwtab}
\usepackage{mathenv}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{semantic} % for the \mathlig function

\usepackage[format=hang]{caption,subfig}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage[final]{listings} % Make sure we show the listing even though we are
                             % making a final report.
\usepackage{ulem} % \sout - strike-through
\usepackage{tikz}

\lstset{ %
% language=Octave,                % choose the language of the code
basicstyle=\ttfamily,        % the size of the fonts that are used for the code
basewidth=0.5em,
% numbers=left,                   % where to put the line-numbers
% numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
% stepnumber=2,                   % the step between two line-numbers. If it's 1 each line will be numbered
% numbersep=5pt,                  % how far the line-numbers are from the code
% backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
% showspaces=false,               % show spaces adding particular underscores
% showstringspaces=false,         % underline spaces within strings
% showtabs=false,                 % show tabs within strings adding particular underscores
% frame=single	                % adds a frame around the code
% tabsize=2,	                % sets default tabsize to 2 spaces
% captionpos=b,                   % sets the caption-position to bottom
% breaklines=true,                % sets automatic line breaking
% breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
escapeinside={(@}{@)}          % if you want to add a comment within your code
}

\renewcommand{\ttdefault}{txtt} % Bedre typewriter font
%\usepackage[sc]{mathpazo}     % Palatino font
\renewcommand{\rmdefault}{ugm} % Garamond
%\usepackage[garamond]{mathdesign}

%\overfullrule=5pt
%\setsecnumdepth{part}
\setcounter{secnumdepth}{1} % Sæt overskriftsnummereringsdybde. Disable = -1.
\chapterstyle{hangnum} % changes style of chapters, to look nice.

\makeatletter
\newenvironment{nonfloatingfigure}{
  \vskip\intextsep
  \def\@captype{figure}
  }{
  \vskip\intextsep
}

\newenvironment{nonfloatingtable}{
  \vskip\intextsep
  \def\@captype{table}
  }{
  \vskip\intextsep
}
\makeatother

\renewcommand{\ttdefault}{txtt} % Bedre typewriter font
%% \usepackage[sc]{mathpazo}     % Palatino font
%% \renewcommand{\rmdefault}{ugm} % Garamond
%% \usepackage[garamond]{mathdesign}

% \overfullrule=5pt
% \setsecnumdepth{part}
\setcounter{secnumdepth}{1} % Sæt overskriftsnummereringsdybde. Disable = -1.
\chapterstyle{hangnum} % changes style of chapters, to look nice.

\theoremstyle{definition}
\newtheorem{judgment}{Judgment}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}

\newcommand*{\fancyrefdeflabelprefix}{def}
\fancyrefaddcaptions{english}{
  \newcommand*{\Frefdefname}{Definition}
  \newcommand*{\frefdefname}{\MakeLowercase{\Frefdefname}}
}
\frefformat{vario}{\fancyrefdeflabelprefix}{%
  \frefdefname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyrefdeflabelprefix}{%
  \Frefdefname\fancyrefdefaultspacing#1#3%
}

\newcommand*{\fancyreflemlabelprefix}{lem}
\fancyrefaddcaptions{english}{
  \newcommand*{\Freflemname}{Lemma}
  \newcommand*{\freflemname}{\MakeLowercase{\Freflemname}}
}
\frefformat{vario}{\fancyreflemlabelprefix}{%
  \freflemname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyreflemlabelprefix}{%
  \Freflemname\fancyrefdefaultspacing#1#3%
}
\frefformat{plain}{\fancyreflemlabelprefix}{%
  \freflemname\fancyrefdefaultspacing#1%
}
\Frefformat{plain}{\fancyreflemlabelprefix}{%
  \Freflemname\fancyrefdefaultspacing#1%
}

\newcommand*{\fancyrefthmlabelprefix}{thm}
\fancyrefaddcaptions{english}{
  \newcommand*{\Frefthmname}{Theorem}
  \newcommand*{\frefthmname}{\MakeLowercase{\Frefthmname}}
}
\frefformat{vario}{\fancyrefthmlabelprefix}{%
  \frefthmname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyrefthmlabelprefix}{%
  \Frefthmname\fancyrefdefaultspacing#1#3%
}

\newcommand*{\fancyrefcorlabelprefix}{cor}
\fancyrefaddcaptions{english}{
  \newcommand*{\Frefcorname}{Corollary}
  \newcommand*{\frefcorname}{\MakeLowercase{\Frefcorname}}
}
\frefformat{vario}{\fancyrefcorlabelprefix}{%
  \frefcorname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyrefcorlabelprefix}{%
  \Frefcorname\fancyrefdefaultspacing#1#3%
}

\newcommand*{\fancyrefexlabelprefix}{ex}
\fancyrefaddcaptions{english}{
  \newcommand*{\Frefexname}{Example}
  \newcommand*{\frefexname}{\MakeLowercase{\Frefexname}}
}
\frefformat{vario}{\fancyrefexlabelprefix}{%
  \frefexname\fancyrefdefaultspacing#1#3%
}
\Frefformat{vario}{\fancyrefexlabelprefix}{%
  \Frefexname\fancyrefdefaultspacing#1#3%
}
\frefformat{plain}{\fancyrefexlabelprefix}{%
  \frefexname\fancyrefdefaultspacing#1%
}
\Frefformat{plain}{\fancyrefexlabelprefix}{%
  \Frefexname\fancyrefdefaultspacing#1%
}

\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\tnm}[1]{\textnormal{#1}}
\newcommand{\mrm}[1]{\mathrm{#1}}

\newcommand{\Cov}{\mathrm{Cov}}
\providecommand{\FV}{\mathrm{FV}}
\providecommand{\Dom}{\mathrm{Dom}}


\mathlig{||}{\parallel}
\mathlig{<'}{\prec}
\mathlig{>'}{\succ}
\mathlig{<='}{\preccurlyeq}
\mathlig{>='}{\succcurlyeq}
\mathlig{<=}{\leqslant}
\mathlig{>=}{\geqslant}
\mathlig{<>}{\neq}
\mathlig{|=}{\sqsubset}
\mathlig{=|}{\sqsupset}
\mathlig{==}{\equiv}
\mathlig{==a}{=_{\alpha}}
\mathlig{<|}{\lhd}
\mathlig{|>}{\rhd}
\mathlig{++}{\mathrel{\mbox{+\!\!\!+}}}
% ~>e or ~>g conflicts with the \cite command for some reason.
\mathlig{->e}{\stackrel{elim}{\leadsto}}
\mathlig{->g}{\stackrel{gen}{\leadsto}}
\mathlig{->n}{\leadsto^n}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	    	     Forside
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter % open mode for reading @ signed variables 
\def\maketitle{%
  \null
  \thispagestyle{empty}%
  \vfill
  \begin{center}\leavevmode
    \normalfont
    \Huge{\raggedleft \@title\par}%
    \hrulefill\par
    \Large{\raggedright \subtitle\par}%
    \vskip 2cm
    {\@date\par}%
  \end{center}%
  \vfill
\begin{minipage}{80pt}
\includegraphics*[scale=0.75]{imgs/nat-logo}
\end{minipage}
\begin{minipage}{300pt}
  \begin{flushleft}
    {\large \@author } \\
    {\footnotesize \suplementInfo }

  \end{flushleft}
\end{minipage}
\cleardoublepage % lave 1 ekstre side blank efter
  \clearpage % Terminates the page here. Everything else vil be placed on next page.
}
\makeatother % closing mode for reading @ signed variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		Data til forside
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Regular-expression based bit coding}
\def\subtitle{\footnotesize{TiPL - Topics in Programming Languages.}}
\author{Morten Brøns-Pedersen {\footnotesize (mortenbp@gmail.com)}\\
Jesper Reenberg {\footnotesize (jesper.reenberg@gmail.com)} \\
Nis Wegmann {\footnotesize (niswegmann@gmail.com)}}

\def\suplementInfo{
  \kern 5pt \hrule width 11pc \kern 5pt % putter 5pt spacing oven over og neden under stregen
  Dept. of Computer Science \\
  University of Copenhagen}
% \date{} % used to set explicit dates

\pagestyle{plain}

\begin{document}

\frontmatter

\maketitle
\thispagestyle{empty}


\begin{abstract}
Foo bar
\end{abstract}

\clearpage 

\tableofcontents*

\mainmatter

\section{Introduction}



\section{Automated Derivation of Regular Expressions from XML Schemas}

\section{$\mu$-Recursion}

\subsection{Definition}

\subsection{Motivation}

\subsection{Bit coding}

\subsection{Normalising}

We introduce tail-recursive $\mu$-types as described in \cite{heni10}.\\[1em]

Regular expressions offers a very restricted form of recursion namely the Kleene
star. This has an impact when we consider the bit code produced from a
particular parse tree.

To see the problem with the Kleene star from a bit coding perspective consider
the unfolding of $E^{\ast}$. It is $1 + E \times E^{\ast}$. It only takes one
bit to code the $1$. But for each Kleene star the $1$-branch is only taken
once. On the other hand each bit coding of $E$ is prefixed with one extra
bit.

If we could trade a longer code for $1$ for shorter codes for $E$ we expect to
gain higher compression rates.

Therefore we generalise recursion to tail-recursive $\mu$-types. Let the
language of expressions $UnReg_{\Sigma}^{\mu}$ over a finite alphabet $\Sigma =
\{a_1, \ldots, a_n\}$ be
\[
\alpha ::= 0 | 1 | a | \alpha_1 + \alpha_2 | \alpha_1 \times \alpha_2 | \mu
X. \alpha | X
\]

The free variables of $\alpha$ is the set of variables $X$ in $\alpha$ that is
not guarded by $\mu X$. If $\alpha$ has no free variables it is closed. The term
$\alpha$ is tail-recursive if $\alpha_1$ is closed in all subexpressions of the
form $\alpha_1 \times \alpha_2$.

The language $Reg_{\Sigma}^{\mu}$ is the closed tail-recursive expressions of
$UnReg_{\Sigma}^{\mu}$.

Of course we need inhabitation rules for this new kind of expressions. But we
can reuse the rules for regular regular expressions except for the fold-rule
which now need to handle $\mu$-expressions. It becomes
\[
\inference{v : \alpha \lbrack \mu X. \alpha / X \rbrack}{\mathtt{fold}\ v : \mu X. \alpha}
\]

Theorem 9 in \cite{heli10} states that $Reg_{\Sigma}^{\mu}$ describes exactly
the same languages as $Reg_{\Sigma}$:
\begin{enumerate}
\item $\forall E \in Reg_{\Sigma} : \exists \alpha \in Reg_{\Sigma}^{\mu} :
  \{||v|| | |- v : E\} = \{||v|| | |- v : \alpha \}$
\item $\forall \alpha \in Reg_{\Sigma}^{\mu} : \exists E \in Reg_{\Sigma} :
  \{||v|| | |- v : \alpha\} = \{||v|| | |- v : E \}$
\end{enumerate}

And the proof of $1.$ tells us how to convert a regular expression into an
equivalent one using $\mu$-recursion: Replace every $E^{\ast}$ with $\mu X.1 +
\alpha \times X$ where $\alpha$ is the conversion of $E$.

\subsection{Normalising $\mu$-expressions}

One gains nothing just by converting a regular expression to an equivalent
$\mu$-recursive one by the rule given above. Consider an example: bit code the
string $aab$ under the regular expression $(a + (b + c))^{\ast}$. The bit codes
for $a$ and $b$ under $(a + (b + c))$ being $0$ and $10$ respectively we get
$10101100$.

Now bit code the same string under the equivalent $\mu X. 1 + (a + (b + c))
\times X$. Again the result is $10101100$.

But observe that $\mu X. 1 + (a + (b + c)) \times X = \mu X. a \times X + (b
\times X + (c \times X + 1))$. Bit coding $aab$ with regard to the latter yields
the code $0010$. That is a reduction of 50\%.

The reason why the bit code under the latter regular expression is shorter is
that the $1$ is buried inside the sum. That way we don't use a full bit per
character to code that the string is not finished yet.

It is easy to automatically balance a sum (see \fref{sec:sum-balancing-using})
but that doesn't immediately help as the ``$\times X$'' prevents us from
including the $1$ in the balancing.

Luckily we can exploit the distributivity of $\times$ with respect to $+$. We
rewrite $\mu$-recursive expressions to their normal form using the following
system of inference rules.

\[
\inference{\gamma \times \alpha + \gamma \times \beta ->n \delta}{\gamma \times
  (\alpha + \beta) ->n \delta} \qquad
\inference{\alpha \times \gamma + \beta \times \gamma ->n \delta}{(\alpha +
  \beta) \times \gamma ->n \delta}
\]

\[
\inference{\alpha ->n \alpha' & \beta ->n \beta'}{\alpha + \beta ->n \alpha' +
  \beta'} \qquad
\inference{\alpha ->n \alpha'}{\mu X. \alpha ->n \mu X. \alpha'}
\]

\[
\inference{\alpha ->n \alpha' & \beta ->n \beta'}{\alpha \times \beta ->n \alpha'
  \times \beta'}(\alpha \neq \alpha_1 + \alpha_2 \land \beta \neq \beta_1 + \beta_2)
\]

\[
\inference{}{a ->n a} \qquad
\inference{}{1 ->n 1} \qquad
\inference{}{0 ->n 0} \qquad
\inference{}{X ->n X}
\]

\begin{lemma}
  Given an expression $\alpha$ it has a unique normal form $\alpha ->n \alpha'$.
  \begin{proof}
    The rules are clearly deterministic. Then the result follows immediately.
  \end{proof}
\end{lemma}

\begin{lemma}
  An expression is equivalent to its normal form. If $\alpha ->n \alpha'$ then
  $\alpha = \alpha'$.
  \begin{proof} (Sketch).
    Since the inference rules for normal form conversion are defined for
    possibly non-closed expressions we need to prove a stronger property. Namely
    for all closed expressions $\alpha_i$ if $\alpha ->n \alpha'$ then $\alpha
    \lbrack \alpha_i / X_i \rbrack = \alpha' \lbrack \alpha'_i / X_i \rbrack$
    where the $X_i$'s are the free variables of $\alpha$ and $\alpha_i ->n
    \alpha'_i$. It is easy to see that the free variables of $\alpha$ and
    $\alpha'$ are the same.

    To prove the lemma we would need a system for proving containment among
    tail-recursive closed $\mu$-expressions. Alas we do not have such a system
    but we speculate that the system of \cite{heli} is still sound and complete
    with the additional rule
    \[
    rec :
  \end{proof}
\end{lemma}

% \begin{lemma}
%   Conversion to normal form preserves bit coding size. That is if the finite
%   string $s$ is encoded as $\mathfrak{b}$ under $\alpha$, $\alpha ->n \alpha'$
%   and $s$ is encoded as $\mathfrak{b'}$ under $\alpha'$ then $| \mathfrak{b}| =
%   | \mathfrak{b'}|$.
%   \begin{proof}
%     Since the inference rules are defined for possibly non-closed expressions we
%     need to prove a stronger property. Namely for all $\alpha_i$ that if $s$ is
%     encoded as $\mathfrak{b}$ under $\alpha \lbrack \alpha_i / X_i \rbrack$,
%     $\alpha ->n \alpha'$ and $s$ is encoded as $\mathfrak{b'}$ under $\alpha'
%     \lbrack \alpha'_i / X_i \rbrack$ then $| \mathfrak{b} | = | \mathfrak{b'}
%     |$. The $X_i$'s are the free variables of $\alpha$ and $\alpha_i ->n
%     \alpha'_i$. It is easy to see that the free variables of $\alpha$ and
%     $\alpha'$ are the same.

%     The result follows by structural induction on the normalisation rules. The
%     only rules that might need explanation are the first two. They are analogous
%     so we just prove the result for the first one.

%     By induction we have that encoding $s$ under $\gamma \times \alpha + \gamma
%     \times \beta$ yields a code, $\mathfrak{b}$ of the same length that encoding
%     under $\delta$ does. We need to show that encoding under $\gamma \times
%     (\alpha + \beta$ gives a code of the same length. The first bit of $\mathfrak{b}
%   \end{proof}
% \end{lemma}

\section{Sum balancing using Huffman coding}\label{sec:sum-balancing-using}

\section{Implementation}

\section{Experimental Results}

\section{Conclusion}

\subsection{Future Work}

%\addcontentsline{toc}{section}{References}
%\bibliographystyle{amsplain}
%\bibliography{mybib}

\bibliographystyle{../bibliography/theseurl}
\bibliography{../bibliography/bibliography}

\end{document}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
