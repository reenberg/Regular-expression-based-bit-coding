% xcolor=table is because it seems that beamer uses the xcolor package in a
% strange way and thus don't accept us giving arguments to the package.
\documentclass[slidestop,compress,mathserif, xcolor=table]{beamer}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}


% \usepackage{mdwtab}
% \usepackage{mathenv}
% \usepackage{amsfonts}
% \usepackage{amsmath}
% \usepackage{amssymb}
% \usepackage{amsthm}
\usepackage{semantic}
\renewcommand{\ttdefault}{txtt} % Bedre typewriter font

% Use the NAT theme in uk (also possible in DK)
\usetheme[nat,uk, footstyle=low]{Frederiksberg}

% Make overlay sweet nice by having different transparancy depending on how
% "far" ahead the overlay is. AWSOME!!
\setbeamercovered{highly dynamic}
% possible to shift back, so they are just invisible untill they should overlay
%\setbeamercovered{invisible}



\usepackage{tikz}
\usetikzlibrary{calc,shapes,arrows}
% below is for use of backgrounds (foregrounds are not used so they are not
% added to this specification).
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}


\usepackage{subfigure}


% Write a short text to have that shown in the footer of slides other than the
% title slide.
\title[]{TiPL - Topics in Programming Languages}
% A possible subslide.
\subtitle{Regular-expression based bit coding}


\author[Morten Brøns-Pedersen \and Jesper Reenberg \and Nis Wegmann]
       {Morten Brøns-Pedersen \and
        Jesper Reenberg  \\
        Nis Wegmann }

% Only write DIKU in the footer of slides (except the title slide).
\institute[DIKU]{Department of Computer Science}

% Remove the date stamp from the footer of slides (except title slide) by giving
% it no short "text"
\date[]{\today} 

\begin{document}

\frame[plain]{\titlepage}

\section{Bit coding}

\subsection{Introduction}

\begin{frame}
  \frametitle{Introduction}
  
  Ordinary texts use space encoding information that is not necessarily used whereas
  regular expressions that have a smaller alphabet can use this as an advantage,
  and not encode information that can not be expressed within the given regular
  expression.
  
  Bit coding originates as a special case of Proof-Carrying Code.
  
\end{frame}

\begin{frame}
  \frametitle{Proof-Carrying Code -- (Ultra) Short intro}
  
  \begin{definition}[Weak]
    Is a technique that can verify properties about an application using formal
    proofs that accompanies the executable code.
  \end{definition}

  Originally described by George Necula and Peter Lee in 1996 (FIXME
  bibliography) to enforce system security policies such as

  \begin{itemize}
  \item Memory safety
  \item Buffer overflows
  \item Etc.
  \end{itemize}

  Specifically for use in kernel modules.

\end{frame}

\begin{frame}
  \frametitle{Proof-Carrying Code -- the special case}

  Originally Necula and Lee used formal proofs (fixme in some decution system)
  which had the disadvantage of being (fixme) 30\% larger than the executable
  code in the general case.

  In 2001 Necula and Rahul (FIXME bibliography) changed the fundamental idea of
  how PCC could be verified, introducing an oracle to guide the proof checker
  instead of the formal proof.

  This resulted in a drop down in ``proof'' size to (FIXME)
  
\end{frame}

\begin{frame}
  \frametitle{Which property to verify}
  
  So how does PCC relate to bit coding?

  If we choose membership testing as the property that needs to be verified,
  then we can look at the verification process as de-compression as it produces a
  wideness (the compressed text) and we can look at the oracle generation as the
  compression 
  
  Such a property could be membership testing
  
\end{frame}

% From udkast_morten.txt
\begin{frame}
  \frametitle{What is an oracle?}
  When one has to make a choice (e.g. when nondeterminism arises) one can
  consult an oracle which (who?) will make the ``right'' choice as if by magic.
\end{frame}

\begin{frame}
  \frametitle{Review of Henglein \& Nielsens axiomatization.}
  \begin{itemize}
  \item Regular expressions as types. A regular expression is a set of proofs of
    membership rather than strings.
  \item Computational interpretation of containment. E.g a total function from
    proofs in a regular expressions to proofs in a containing one (coercions).
  \item Parametric completeness ($|- c : E[X_1, \ldots, X_n] \leq F[X_1,
    \ldots, X_n]$).
  \item Oracle based bit coding of proof values and transformation of oracles.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recall membership and inhabitation:}

  \begin{columns}[totalwidth=0.8\textwidth]
    \begin{column}{.5\textwidth}
      \[
      \inference{}{\epsilon \in 1}
      \]
      \[
      \inference{}{\texttt{a} \in \texttt{a}}
      \]
      \[
      \inference{s \in E}{s \in E + F}
      \]
      \[
      \inference{s \in F}{s \in E + F}
      \]
      \[
      \inference{s \in E & t \in F}{st \in E \times F}
      \]
      \[
      \inference{s \in 1 + E \times E^{\ast}}{s \in E^{\ast}}
      \]
    \end{column}
    \begin{column}{.5\textwidth}
      \[
      \inference{}{() : 1}
      \]
      \[
      \inference{}{\texttt{a} : \texttt{a}}
      \]
      \[
      \inference{v : E}{\mathtt{inl}\ v : E + F}
      \]
      \[
      \inference{v : E}{\mathtt{inr}\ v : E + F}
      \]
      \[
      \inference{v : E & w : F}{(v, w) : E \times F}
      \]
      \[
      \inference{v : 1 + E \times E^{\ast}}{\mathtt{fold}\ v : E^{\ast}}
      \]
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Using an oracle.}
  So lets try and construct a proof of membership in $\mathcal{L}|[E|]$.
  \only<+>{
    \[
    \inference{\mathcal{T}}{|- c : E}
    \]
  }
  \only<+>{
    \[
    \inference{\mathcal{T}_3}{|- c : E}
    \]
  }
  \only<+>{
    \[
    \inference{\mathcal{T}_3}{|- c : E + E}
    \]
  }
\end{frame}

\begin{frame}
  \frametitle{Nondeterminism.}
  There is only one place where the next rule in the proof cannot be determined
  by the structure of the regular expression. Namely alternation.

  \begin{columns}[totalwidth=0.8\textwidth]
    \begin{column}{.5\textwidth}
      \[
      \inference{}{() : 1}
      \]
      \[
      \inference{}{\texttt{a} : \texttt{a}}
      \]
      \[
      \inference{v : E}{\mathtt{inl}\ v : E + F}
      \]
      \[
      \inference{v : E}{\mathtt{inr}\ v : E + F}
      \]
    \end{column}
    \begin{column}{.5\textwidth}
      \[
      \inference{v : E & w : F}{(v, w) : E \times F}
      \]
      \[
      \inference{v : 1 + E \times E^{\ast}}{\mathtt{fold}\ v : E^{\ast}}
      \]
    \end{column}
  \end{columns}

  \vspace{1em}
  Either choose \texttt{inl} or \texttt{inr}.
\end{frame}

\begin{frame}
  \frametitle{Nondeterministic membership prover.}

  \begin{quote}
    [Jespers maskine - med eller uden spøgelse i]
  \end{quote}
\end{frame}

\begin{frame}
  \frametitle{Constructing an oracle.}
  Lets construct an oracle for the proof of membership of the string
  \texttt{foobarbaz} in $\mathcal{L}|[E|]$.\\[1em]
  \only<+>{
    $.$
  }
  \only<+>{
    $\phantom{.}.$
  }
  \only<+>{
    $\phantom{..}.$
  }
  \only<+>{
    $\phantom{...}.$
  }
  \only<+>{
    $\phantom{....}.$
  }
\end{frame}

\begin{frame}
  \frametitle{Oracle based bit coding.}

  \only<+>{
    Now we've seen how to use and create oracles. Here are the rules:
    \begin{block}{Encoding}
      \begin{eqnarray*}
        code(() : 1) &=& \epsilon \\
        code(\mathtt{a} : \mathtt{a}) &=& \epsilon \\
        code(\mathtt{inl}\ v : E + F) &=& \mathtt{0}code(v : E) \\
        code(\mathtt{inr}\ v : E + F) &=& \mathtt{1}code(v : F) \\
        code((v, e) : E \times F)     &=& code(v : E)code(w : F) \\
        code(\mathtt{fold}\ v : E^{\ast}) &=& code(v : 1 + E \times E^{\ast})
      \end{eqnarray*}
    \end{block}
  }
  \only<+>{
    \begin{block}{Decoding}
      {\scriptsize
      \begin{eqnarray*}
        decode'(d : 1) &=& (() : 1) \\
        decode'(d : \mathtt{a}) &=& (\mathtt{a}, d) \\
        decode'(\mathtt{0}d : E + F) &=& \mathbf{let}\ (v, d') <- decode'(d : E) \\
        && \mathbf{in}\ (\mathtt{inl}\ v, d') \\
        decode'(\mathtt{1}d : E + F) &=& \mathbf{let}\ (v, d') <- decode'(d : F) \\
        && \mathbf{in}\ (\mathtt{inr}\ v, d') \\
        decode'(d : E \times F) &=& \mathbf{let}\ (v, d') <- decode'(d : E) \\
        && \phantom{\mathbf{let}}\ (w, d'') <- decode'(d' : F) \\
        && \mathbf{in}\ ((v, w), d'') \\
        decode'(d : E^{\ast}) &=& \mathbf{let}\ (v, d') <- decode'(d : 1 + E
        \times E^{\ast}) \\
        && \mathbf{in}\ (\mathtt{fold}\ v, d') \\
        decode(d : E) &=& \mathbf{let}\ (v, d') <- decode'(d : E) \\
        && \mathbf{in}\ \mathbf{if}\ d' = \epsilon\ \mathbf{then}\ v\
        \mathbf{else}\ error
      \end{eqnarray*}
    }
    \end{block}
  }
\end{frame}

\begin{frame}
  \frametitle{Choosing the right regular expression.}

  \begin{quote}
    [Jespers rather nice example]
  \end{quote}
\end{frame}

\begin{frame}
  Maybe: Practical use:
  [example (motivation for coercions): a piece of code where each branch of a
  conditional returns oracles belonging to different regex'es, all contained in a
  'master' regex OR regular expression adapting to network traffic]
\end{frame}

\begin{frame}
  \frametitle{Remember coercions?}
  \only<+>{
    A coercion is a proof of containment...

    \begin{quote}
      [Figure 9.]
    \end{quote}
  }
  \only<+>{
    ...with a computational interpretation.

    \begin{quote}
      [Figure 10.]
    \end{quote}
  }
  \only<+>{
    \begin{block}{Definition 3.}
      [foobarbaz]
    \end{block}
    In short: Coercions transform our membership proofs from one regular
    expression to another.
  }
\end{frame}

\begin{frame}
  \frametitle{Coercion synthesis.}
  Coercions can be synthesised automatically. Surely everyone remembers this:

  \begin{quote}
    [Figure 19 for 'wow' effect.]
  \end{quote}
\end{frame}

\begin{frame}
  \frametitle{Choosing the right regular expression (revisited).}

  \begin{quote}
    [From Jespers rather nice example: $E = a + (b + (c + d))$, $E' = ((a + b) +
    c) + d$ (or something like that).]
  \end{quote}
  For our particular membership proofs (strings) we expect the oracles for $E'$
  to be smaller than for $E$.\\[1em]

  Clearly $\mathcal{L}|[E|] = \mathcal{L}|[E'|]$ and thus $\mathcal{L}|[E|]
  \subseteq \mathcal{L}|[E'|]$. By the soundness and completeness of the rules
  for containment we have $|- c : E \leq E'$.\\[1em]

  So we can convert $v \in E$ to $w \in E'$ by $\mathcal{F}|[c|]$ (and of course
  $||v|| = ||w||$).
\end{frame}

\begin{frame}
  \frametitle{Coercion of oracles.}
  \only<+>{
  Find a $\hat{c}$ that converts oracles for proofs in $E$ to oracles for proofs
  in $E'$ (provided $E \leq E'$).

    \begin{itemize}
    \item Naïvely: If $|- c : E \leq E'$, then $\mathcal{F}|[\hat{c}|] =
      \texttt{code} \circ \mathcal{F}|[c|] \circ \texttt{decode}$.
    \item Directly.
    \end{itemize}
  }
  \only<+>{
    \begin{quote}
      [Figure 23.]
    \end{quote}
  }
\end{frame}
% END (From udkast_morten.txt)

\begin{frame}
  \frametitle{Abstract idea of bit compression using oracles}

  \tikzstyle{block} = [draw, fill=blue!20, rectangle, minimum height=3em,
  minimum width=6em]
  
  \tikzstyle{fun} = []

  \tikzstyle{machine} = [fill=blue!20, rectangle, rounded corners,
  minimum width = 4em, minimum height = 3em]
  
  \begin{figure}[ht]
    \centering
    
    \subfigure[Encoding]{
      \begin{tikzpicture}
        \node [machine]  (machine) {encode};
        
        \node [fun,left of=machine, xshift=-0.7cm]  (text) {Text};
        \node [fun, above of=machine, yshift=0.2cm] (regex) {Regular expression};
        
        \node [fun, right of=machine, xshift=0.7cm] (bits) {Bits};
        
        \draw[->] (regex) -- (machine);
        \draw[->] (text) -- (machine);
        \draw[->] (machine) -- (bits);
        
        % print a nice background
        \begin{pgfonlayer}{background}
          \path[fill=green!10,rounded corners]
          ($(current bounding box.south west) - (.2,.2)$) rectangle
          ($(current bounding box.north east) + (.2,.2)$);
        \end{pgfonlayer}    
      \end{tikzpicture}
    }

    \subfigure[Decode]{
      \begin{tikzpicture}
        \node [machine]  (machine) {decode};
        
        \node [fun,left of=machine, xshift=-0.7cm]  (text) {Text};
        \node [fun, above of=machine, yshift=0.2cm] (regex) {Regular expression};
        
        \node [fun, right of=machine, xshift=0.7cm] (bits) {Bits};
        
        \draw[->] (regex) -- (machine);
        \draw[<-] (text) -- (machine);
        \draw[<-] (machine) -- (bits);
        
        % print a nice background
        \begin{pgfonlayer}{background}
          \path[fill=green!10,rounded corners]
          ($(current bounding box.south west) - (.2,.2)$) rectangle
          ($(current bounding box.north east) + (.2,.2)$);
        \end{pgfonlayer}    
        
      \end{tikzpicture}
    }

  \end{figure}
  
\end{frame}

\begin{frame}
  
  Thus it is important that the regular expression is constructed in a clever
  way, such that the representation of the regular expression is small
  
  (a|b|..|z)* vs [a-z]* 
  
  As discussed in previous talks about bit coding (and later) it is only the
  alternation and thus also the Kleene star ($1 + E \times E^{\ast}$) that generate
  any bits in the resulting bit code.  Thus it is important how the regular
  expression is expressed.

  \begin{block}{Simplified subset of \texttt{code} function}
\begin{semiverbatim}
  \center{code(inl v) => 0 \quad code(inr v) => 1}
\end{semiverbatim}
  \end{block}

  \begin{example}
    Text: dc\\
    Regex: a|(b|(c|d))
    
    \only<+>{( inr ( inr ( inr d ) ) , inr ( inr ( inl c ) ) )}
    \only<+>{\alert{( inr ( inr ( inr d ) ) , inr ( inr ( inl c ) ) )}}
    \only<+>{( \alert{inr ( inr ( inr d ) )} , inr ( inr ( inl c ) ) )}
    \only<+>{( 1 \alert{inr ( inr d )} , inr ( inr ( inl c ) ) )} 
    \only<+>{( 1 1 \alert{inr d} , inr ( inr ( inl c ) ) )} 
    \only<+>{( 1 1 1 , inr ( inr ( inl c ) ) )} 
    \only<+>{( 1 1 1 , \alert{inr ( inr ( inl c ) )} )}
    \only<+>{( 1 1 1 , 1 \alert{inr ( inl c )} )} 
    \only<+>{( 1 1 1 , 1 1 \alert{inl c} )} 
    \only<+>{( 1 1 1 , 1 1 0)} 
    \only<+>{1 1 1 1 1 0}
  \end{example}

\end{frame}

\begin{frame}

  \begin{block}{Simplified subset of \texttt{code} function}
\begin{semiverbatim}
  \center{code(inl v) => 0 \quad code(inr v) => 1}
\end{semiverbatim}
  \end{block}
  
  But if we shift the regular expression so d is in the beginning and then having 

  Where if we represent the regex as d|(a|(b|c)) we get

  \begin{example}
    Text: dc\\
    Regex: b|(c|(a|b))

    \only<+>{( inl d , inr ( inl c ) )}
    \only<+>{\alert{( inl d , inr ( inl c ) )}}
    \only<+>{( \alert{inl d} , inr ( inl c ) )}
    \only<+>{( 0 , inr ( inl c ) )}
    \only<+>{( 0 , \alert{inr ( inl c )} )}
    \only<+>{( 0 , 1 \alert{inl c} )}
    \only<+>{( 0 , 1 0 )}
    \only<+>{0 1 0}
  \end{example}

  (inl d, inr (inl c)) => 010.

  Thus statical analysis (minimising alphabet and occurrence checks) of the text
  to compress can sometime yield huge gains.
  In general this is not so easy, but structured texts as XML files, with a
  specifying schema it gets quite easy.

\end{frame}

\section{Bit coding}

\subsection{Theory}

\begin{frame}
  \frametitle{Naive usage}
  
\end{frame}

\begin{frame}
  \frametitle{Naive usage -- Practical example}
  Henglein Fig 8 med praktisk eksempel på hvilke bits der kommer ud
\end{frame}


\begin{frame}[c]
  \frametitle{Pop quiz}
  
  
  \begin{center}
    \huge{2min quiz}
  \end{center}

\end{frame}

\begin{frame}[c]
  \frametitle{Pop quiz -- Solutions}
  

% define nice colors for tables
\rowcolors[]{1}{green!20}{green!10}


  \begin{center}
    % temporarily disable the bad ass niceness highly dynamic fading of
    % overlays.
    \setbeamercovered{invisible}
    \begin{tabular}{l|l||c|c|c}
      \emph{Regex} & \emph{Text} & \emph{1} & \emph{x} & \emph{2} \\ \hline
      a* & aaaaa & 100000 & 000001 & \alert<2>{111110} \pause\pause \\
      (a|b)* & abaab & \alert<4>{10111010110} & 10111010111 & 01110101110 \pause\pause \\
      abdd & abdd & \alert<6>{10}     & 1 & 0 \pause\pause \\
      abdd & abdd & \alert<8>{10}     & 1 & 0 \vspace{1em} \pause\pause \\
      \emph{Regex} & \emph{Bits} & \emph{1} & \emph{x} & \emph{2} \\ \hline
      a* & 1110011 & \alert<10>{aaaa} & aaa & abab \pause\pause \\
      abdd & 0 & \alert<12>{abdd}     & $\epsilon$ & ddba \pause\pause \\
      abdd & 1 & abab     & \alert<14>{ddba} & $\epsilon$ \pause\pause \\
      abdd & 1 & abab     & ddba & \alert<16>{$\epsilon$} \pause\pause \\
    \end{tabular}
    
    % re-enable bad ass niceness hifly dynamic fading of overlays.
    \setbeamercovered{highly dynamic}
  \end{center}
  
\end{frame}

\subsection{Implementation}

\begin{frame}
  \frametitle{Implementation details}
  
  Frisch \& Cardelli dynamic backtracking algorithm

\end{frame}

\begin{frame}
  \frametitle{The naked code}
  
\end{frame}

\section{Preliminary results}

\begin{frame}
  \begin{center}
    \huge{live DEMO of code}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Examined data}
  \begin{itemize}
  \item XML files
    
    \begin{itemize}
    \item DNA sequence
      
    \item DBLP database
    \end{itemize}

  \item RFC papers (technical english texts).
    
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Oracle vs gzip}
  
  off the shelf unix gzip
\end{frame}

\begin{frame}
  \frametitle{Oracle vs Hoffman}
  Compare text with small and large amount of entropy.
\end{frame}

\begin{frame}
  \frametitle{Disadvantages}

  \begin{itemize}
  \item Naive implementation yields(BIBTEX HENGLEIN) compression above 1
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Advantages}

  We have an idea of how to ensure compression below 1, which
\end{frame}

\begin{frame}[fragile]
  \frametitle{Experimental Results}

  Compression of a subset of the following xml-file from DBLP (the Digital Bibliography and Library Project)

{\tiny
\begin{verbatim}
<?xml version="1.0"?>
<dblptags>
<tag key="conf/rsctc/WengZ04">Plagiarized Papers in DBLP</tag>
<tag key="books/ph/KemperM94">Access Support Relations in Textbooks</tag>
<tag key="conf/icde/LitwinL86">1986</tag>
<tag key="journals/software/LitwinL87">1987</tag>
...
</dblptags>
\end{verbatim}
} 

  ... yields the following results:

  \begin{itemize}
  \item Before compression: 14032 bits
  \item Compression using regexps (unbalanced): 31120 bits
  \item Compression using regexps (balanced): 7340 bits
  \item Compression using gzip: 4352 bits
  \end{itemize}

\end{frame}

% \begin{frame} 
%   \frametitle{New style -- Oracle based guidance}

%   Pros.
%      Low memory usage, only a few bits needs to be read from the oracle at a time.
%   Cons.
%      Slower checking time.
     

%   Nondeterministic checker, but with a lot of tricks it is only a small part
%   that is nondeterministic and needs the oracles help.

%   Untrusted oracles is not a problem.

  
  
% \end{frame}

\end{document}





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
